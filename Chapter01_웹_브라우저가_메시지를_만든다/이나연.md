# 웹 브라우저가 메시지를 만든다

1. HTTP 리퀘스트 메세지를 작성한다
2. 웹 서버의 IP 주소를 DNS 서버에 조회한다
3. 전 세계의 DNS 서버가 연대한다
4. 프로토콜 스택에 메시지 송신을 의뢰한다

---

## STORY 01 | HTTP 리퀘스트 메시지를 작성한다

### 1. 탐험 여행은 URL 입력부터 시작한다.

URL(Uniform Resource Locator)

- `http:`, `ftp:`, `file:`, `mailto:`로 시작하는 것 등 여러 가지가 있음

❓다양한 URL이 준비되어 있는 이유는?

브라우저는 웹 서버에 액세스하는 클라이언트로 사용하는 경우가 많지만, 파일을 다운로드/업로드하는 FTP의 클라이언트 기능이나 메일의 클라이언트 기능도 가지고 있음

→ 몇 개의 기능 중의 어느 것을 사용하여 데이터에 액세스하면 좋을 것인지를 판단하는 재료가 필요하기 때문에, 웹 서버에 액세스 할 때 `http:`, `ftp:`라는  식으로 여러 종류의 URL이 준비되어 있음

주요 URL을 쓰는 방법은 액세스의 대상에 따라 다름

- `http:`, `ftp:`, `file:`, `mailto:`는 액세스하는 방법을 나타냄.
- 액세스 대상이 웹 서버라면 HTTP라는 프로토콜을 사용하여 액세스하고, FTP 서버라면 FTP라는 프로토콜을 사용하는 방식

**HTTP 프로토콜로 웹 서버에 액세스하는 경우**
`http://user:password@www.cyber.co.kr:80/dir/file1.html`

user: 사용자명 (생략 가능)

password: 패스워드 (생략 가능)

www.cyber.co.kr: 웹 서버의 도메인명

80: 포트 번호 (생략 가능)

/dir/file1.html: 파일의 경로명

---

### 2. 브라우저는 먼저 URL을 해독한다

**웹 서버에 액세스하는 경우**

**(a) URL의 요소**

`http:` + `//` + `웹 서버명` + `/` + `디렉토리명` + `/` + ……. + `파일명`

http: URL의 맨 앞에는 데이터 출처에 액세스하는 방법, 즉 프로토콜을 기록

//: 나중에 이어지는 문자열이 서버의 이름임을 나타냄

(웹 서버명 뒤는 생략 가능)

**(b) URL의 예**

`http://www.lab.cyber.co.kr/dir1/file1.html`

**(c) (a)의 요소에 맞춰 (b)를 해독한 것**

`http:` + `//` + `[www.lab.cyber.co.kr](http://www.lab.cyber.co.kr)` + `/` + `dir1` + `/` + `file1.html`

www.lab.cyber.co.kr: 웹 서버명

/dir1/file1.html: 데이터 출처(파일)의 경로명

→ `www.lab.cyber.co.kr`이라는 웹 서버에 있는 `/dir1/file1.html`이라는 경로의 파일, 즉 `/dir1/`이라는 디렉토리의 아래에 있는 `file1.html` 파일에 액세스한다는 의미

---

### 3. 파일명을 생략한 경우

****(a) http://www.lab.cyber.co.kr/dir/****

파일명을 생략할 때를 대비하여 파일명을 미리 서버 측에 설정해둠

ex) index.html, default.html

****(b) http://www.lab.cyber.co.kr/****

/라는 디렉토리가 지정되고 파일명 생략

****(c) http://www.lab.cyber.co.kr****

디렉토리명까지 생략

→ 경로명이 아무것도 없는 경우, 루트 디렉토리의 아래에 있는 미리 설정된 파일명의 파일에 액세스

****(d)  http://www.lab.cyber.co.kr/whatisthis****

whatisthis를 파일명으로 보고, whatisthis라는 디렉토리가 있으면 whatisthis를 디렉토리명으로 봄

---

### 4. HTTP의 기본 개념

**HTTP 프로토콜**

: 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것

**HTTP의 동작**

**1) 클라이언트에서 서버를 향해 리퀘스트 메세지를 보냄**

- 무엇을, 어떻게 해서 하겠다는 내용 포함

**URI**는 `무엇을`에 해당

ex) /dir1/file.html, /dir1/program1.cgi, http:~~

→ 다양한 액세스 대상을 쓸 수 있으며, 이러한 액세스 대상을 통칭하는 말이 URI임

**메소드**는 `어떻게 해서`에 해당

- 웹 서버에 어떤 동작을 하고 싶은지를 전달

ex) 클라이언트 측에서 입력한 데이터를 URI로 나타낸 프로그램에 전달하고 싶다는 식의 동작

**2) 리퀘스트 메시지가 웹 서버에 도착하면, 웹 서버는 그 속에 쓰여있는 내용 해독**

- URI와 메시지를 조사하여 무엇을, 어떻게 하는지 판단한 후 요구에 따라 동작하고, 결과 데이터를 응답 메시지에 저장

**스테이터스 코드:** 응답 메시지의 맨 앞부분에 실행 경과가 정상 종료되었는지 또는 이상이 발생했는지 나타냄. ex) 404 Not Found

**3) 헤더 파일과 페이지의 데이터가 이어지고, 이 응답 메시지를 클라이언트에 반송**

**4) 클라이언트에 도착하여 브라우저가 메시지의 안에서 데이터를 추출하여 화면에 표시**


**HTTP의 주요 메소드**

**`GET`:** 보통 웹 서버에 액세스하며 페이지의 데이터를 읽을 때 사용

GET /dir1/file1.html

1) 서버는 dir1/file1.html이라는 파일을 열고 내용의 데이터 추출

2) 추출한 데이터를 응답 메시지에 포함하여 클라이언트에게 반송

3) 클라이언트 측의 브라우저가 이것을 받아 화면에 표시

`**POST**`: 폼에 데이터를 사용해서 웹 서버에 송신하는 경우 사용

1) 리퀘스트 메시지 안에 메시지와 URI를  더불어 CGI 프로그램이나 스크립트에 건네주는 데이터(사용자가 필드에 입력한 값) 사용

2) 메시지가 서버 기계에 도착하면 웹 서버 소프트웨어는 URI에 저장된 애플리케이션 프로그램에게 리퀘스트 메시지의 안에 쓰여있는 데이터를 건네줌

3) 이 프로그램이 출력하는 데이터를 받아서 응답 메시지에 포함시킨 후, 클라이언트에게 반송

`HEAD`: GET과 거의 같음. 하지만, HTTP 메시지 헤더만 반송하고 데이터의 내용을 돌려보내지 않음.

`OPTIONS`: 통신 옵션을 통지하거나 조사할 때 사용

`PUT`: URI로 지정한 서버의 파일을 치환. URI로 지정한 파일이 없는 경우에는 새로 파일을 작성

`DELETE`: URI로 지정한 서버의 파일을 삭제

`TRACE`: 서버 측에서 받은 리퀘스트 라인과 헤더를 그대로 클라이언트에 반송. 프록시 서버 등을 사용하는 환경에서 리퀘스트가 치환되는 상태를 조사할 때 사용

`CONNECT`: 암호화한 메시지를 프록시로 전송할 때 이용하는 메소드

---

### 5. HTTP 리퀘스트 메시지를 만든다

**HTTP 메시지의 포맷**

(a) 리퀘스트 메시지

```
<메소드><공백><URI><공백><HTTP 버전>  —- (가)

<필드명>:<필드값>  —- (나)

…

<공백 행>   —- (나)

<메시지 본문> —- (다)
```

(가): 리퀘스트 라인. 이 한 행으로 리퀘스트의 내용을 대략 알 수 있음

(나): 메시지 헤더. 한 행에 한 개의 헤더 필드를 씀. 이를 통해, 리퀘스트의 부가적인 정보를 나타냄. 행 수는 상황에 따라 달라지며, 공백 행까지가 메시지 헤더가 됨.

(다): 메시지 본문의 내용은 클라이언트에서 서버에 송신하는 데이터. 폼 페이지에 입력한 데이터를 POST 메소드로 웹 서버에 보낼 때 등에 데이터가 들어감.

(b) 응답 메시지

```
<HTTP 버전><공백><스테이터스 코드><공백><응답 문구> --- (가)
<필드명>:<필드값>  --- (나)
...
<공백 행>   --- (나)
<메시지 본문> --- (다)
```

(가): 스테이터스 라인

(나): 메시지 헤더

(다): 메시지 본문으로, 메시지 본문의 내용은 서버에서 클라이언트에 송신하는 데이터. 파일에서 읽은 데이터나 CGI 애플리케이션이 출력한 데이터가 들어감. 메시지 본문은 바이너리 데이터로 취급.

---

### 6. 리퀘스트 메시지를 보내면 응답이 되돌아온다

| 코드값 | 설명 |
| --- | --- |
| 1xx | 처리의 경과 상황 등을 통지 |
| 2xx | 정상 종료 |
| 3xx | 무언가 다른 조치가 필요함을 나타냄 |
| 4xx  | 클라이언트 측의 오류 |
| 5xx | 서버 측의 오류 |

**예시** - html 내 이미지 태그를 포함한 경우

1. 리퀘스트 메시지

```
GET /sample.htm HTTP/1.1
Accept: */*
Accept-Language: ja
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Host: www.lab.glasscom.com
Connection: Keep-Alive
```

1. '/sample1.htm' 의 리스폰스 메시지

```
HTTP/1.1 200 OK
Date: Wed, 7 Oct 2020 13:00:00 GMT
Server: Apache
Last-Modified: Wed, 30 Sep 2020 13:00:00 GMT
ETag: "5a9da-27903c726b61"
Accept-Ranges: bytes
Content-Length: 632
Connection: close
Content-Type: text/html

<html>
<head>
<meta http-equiv-"Content-Type" content="text/html"; charset=utf-8">
<title> 인터넷 탐험 여행</title>
</head>

<body>
<img src="gazou.jpg"/>
</body>
</html>
```

1. '/gazou.jpg' 에 해당하는 리퀘스트 메시지

```
GET /gazou.jpg HTTP/1.1
Accept: */*
Referer: http://www.lab.cyber.co.kr/sample1.htm
Accept-Language: ja
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Host: www.lab.cyber.co.kr
Connection: Keep-Alive
```

1. 리스폰스 메시지

```
HTTP/1.1 200 OK
Date: Wed, 7 Oct 2020 13:00:00 GMT
Server: Apache
Last-Modified: Wed, 30 Sep 2020 13:00:00 GMT
ETag: "5a9da-1913-3aefa236"
Accept-Ranges: bytes
Content-Length: 6419
Connection: close
Content-Type: image/jpeg

바이너리 데이터
```

---

## STORY 02 | 웹 서버의 IP 주소를 DNS 서버에 조회한다

### 1. IP 주소의 기본

**1) HTTP 메시지 만들기**

**2) 메시지를 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신**

→ 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만, 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하여 송신

**3) URL 안에 쓰여있는 서버의 도메인명에서 IP 주소를 조사**

→ OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소로 메시지를 받을 상대를 지정해야 하기 때문

**IP 주소**

TCP/IP는 **서브넷**이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어진다고 생각

- 서브넷: 허브에 몇 대의 PC가 접속된 것이라 생각
- 이것을 한 개의 단위로 생각하여 서브넷이라고 부르는데, 라우터에서 연결하면 네트워크 전체가 완성됨.

→ 허브를 중심으로 몇 대의 컴퓨터가 모여 서브넷을 이루고, 서브넷들은 라우터를 통해 네트워크를 이루게 된다.

**예시)**

ㅇㅇ동 ㅇㅇ번지 라는 형태로 네트워크의 주소를 할당

(동에 해당하는 번호를 서브넷에 할당하고, 번지에 해당하는 번호를 컴퓨터에 할당한 것이 네트워크의 주소)

**네트워크 번호**: 서브넷에 할당된 주소 (동에 해당하는 번호)

**호스트 번호**: 컴퓨터에 할당된 주소 (번지에 해당하는 번호)

**IP 주소**: 네트워크 번호 + 호스트 번호 (이 두 주소를 합친 것)

이 IP 주소에 따라 액세스 대상이 어디에 있는지 판단하고 메시지가 전달됨

1. 송신측 -> 허브
2. 허브 -> 라우터
3. 라우터 -> 라우터
4. 라우터 -> 수신측

**IP 주소의 표기 방법**

**(a) IP 주소 본체의 표기 방법**

`10.11.12.13`

**(b) IP 주소 본체와 같은 방법으로 네트워크를 표기하는 방법**

`10.11.12.13/235.255.255.0`

IP 주소 본체  | 넷마스크

**(c) 네트워크 번호의 비트 수로 넷마스크를 표기하는 방법**

`10.11.12.13/24`

IP 주소 본체 | 넷마스크

**(d) 서브넷을 나타내는 주소**

`10.11.12.0/24`

호스트 번호 부분의 비트가 모두 0인 것은 각 컴퓨터가 아니라 **서브넷** 자체를 나타냄

(e) 서브넷의 브로드캐스트를 나타내는 주소

`10.11.12.255/24`

호스트 번호 부분의 비트가 모두 1인 것은 서브넷 전체에 대한 **브로드캐스트**를 나타냄

넷마스크: 네크워크를 구축할 때 사용자가 직접 내역을 결정할 수 있는데, 이 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧붙이는 정보

호스트 번호 부분이 모두 0인 IP 주소: 각각의 기기를 나타내는 것이 아니라 서브넷 자체를 나타냄

호스트 번호 부분이 모두 1인 IP 주소: 서브넷에 있는 기기 전체에 패킷을 보내는 **브로드캐스트**를 나타냄

---

### 2. 도메인명과 IP 주소를 구분하여 사용하는 이유

TCP/IP의 네트워크는 이 IP 주소로 통신 상대를 지정

→ IP 주소를 모르면 상대에게 메시지 전달 불가

→ OS에 메시지 송신을 의뢰할 때는 IP 주소 조사해야 함

❓URL 안에 도메인명 (서버명)이 아니라 IP주소를 쓰면 좋지 않을까?

IP 주소를 써도 올바르게 작동하지만, IP 주소는 기억하기 어렵기 때문에 URL 안에는 도메인명 (서버의 이름)을 쓰는 것이 좋음

❓IP 주소 대신 도메인명을 사용하지 않는 이유

도메인명은 수십 bytes ~ 255 bytes 를 차지함

→ 라우터에 과부하가 걸림

→ 사람은 도메인명, 라우터는 IP 주소를 사용

**DNS:** 이름을 알면 IP 주소를 알 수 있다거나 IP 주소를 알면 이름을 알 수 있다는 원리를 사용하여 양쪽의 차이를 해소

---

### 3. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다

>
>

**DNS 서버를 어떻게 조회할 수 있을까?**

네임 리졸루션(name resolution, 이름 확인)

- DNS 원리를 사용하여 IP 조사하는 것

DNS 리졸버

- DNS 클라이언트
- 네임 리졸루션을 실행하는 주체
- Socket 라이브러리 내의 하나의 프로그램
    - Socket 라이브러리 : 네트워크 기능 호출을 위한 프로그램 라이브러리

---

### 4. 리졸버를 이용하여 DNS 서버를 조회한다

리졸버는 애플리케이션에서 Socket 라이브러리를 통해 간단히 호출이 가능함

예를 들어

```
<애플리케이션 프로그램의 이름> (<매개변수>)
{
  ...
  <메모리 영역> = gethostbyname("www.lab.cyber.co.kr");\
  ...
  <HTTP 메시지 송신>
}
```

브라우저는 이런 형태로 리졸버를 이용해 IP 주소를 얻고 웹 서버에 메시지를 보냄

---

### 5. 리졸버 내부의 작동

1. 브라우저가 리졸버를 호출하면 제어가 리졸버의 내부로 넘어감
2. 리졸버는 DNS 에 문의하기 위한 메시지를 만듦
3. 리졸버는 직접 메시지를 송신하는 기능을 가지고 있는 것이 아니기 때문에,  OS의 **프로토콜 스택**을 호출하여 실행을 의뢰
4. 프로토콜 스택이 LAN 어댑터를 통해 DNS 서버로 메시지를 송신
5. DNS 서버가 IP 주소를 조회해 응답메시지를 보내줌

❓DNS 서버의 IP 주소는 어떻게 아는 것일까?

TCP/IP 설정 항목의 하나하나로 컴퓨터에 미리 설정되어 있음