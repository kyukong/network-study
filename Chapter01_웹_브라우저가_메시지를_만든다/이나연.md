# 웹 브라우저가 메시지를 만든다

1. HTTP 리퀘스트 메세지를 작성한다
2. 웹 서버의 IP 주소를 DNS 서버에 조회한다
3. 전 세계의 DNS 서버가 연대한다
4. 프로토콜 스택에 메시지 송신을 의뢰한다

---

## STORY 01 | HTTP 리퀘스트 메시지를 작성한다

### 1. 탐험 여행은 URL 입력부터 시작한다.

URL(Uniform Resource Locator)

- `http:`, `ftp:`, `file:`, `mailto:`로 시작하는 것 등 여러 가지가 있음

❓다양한 URL이 준비되어 있는 이유는?

브라우저는 웹 서버에 액세스하는 클라이언트로 사용하는 경우가 많지만, 파일을 다운로드/업로드하는 FTP의 클라이언트 기능이나 메일의 클라이언트 기능도 가지고 있음

→ 몇 개의 기능 중의 어느 것을 사용하여 데이터에 액세스하면 좋을 것인지를 판단하는 재료가 필요하기 때문에, 웹 서버에 액세스 할 때 `http:`, `ftp:`라는  식으로 여러 종류의 URL이 준비되어 있음

주요 URL을 쓰는 방법은 액세스의 대상에 따라 다름

- `http:`, `ftp:`, `file:`, `mailto:`는 액세스하는 방법을 나타냄.
- 액세스 대상이 웹 서버라면 HTTP라는 프로토콜을 사용하여 액세스하고, FTP 서버라면 FTP라는 프로토콜을 사용하는 방식

**HTTP 프로토콜로 웹 서버에 액세스하는 경우**
`http://user:password@www.cyber.co.kr:80/dir/file1.html`

user: 사용자명 (생략 가능)

password: 패스워드 (생략 가능)

www.cyber.co.kr: 웹 서버의 도메인명

80: 포트 번호 (생략 가능)

/dir/file1.html: 파일의 경로명

---

### 2. 브라우저는 먼저 URL을 해독한다

**웹 서버에 액세스하는 경우**

**(a) URL의 요소**

`http:` + `//` + `웹 서버명` + `/` + `디렉토리명` + `/` + ……. + `파일명`

http: URL의 맨 앞에는 데이터 출처에 액세스하는 방법, 즉 프로토콜을 기록

//: 나중에 이어지는 문자열이 서버의 이름임을 나타냄

(웹 서버명 뒤는 생략 가능)

**(b) URL의 예**

`http://www.lab.cyber.co.kr/dir1/file1.html`

**(c) (a)의 요소에 맞춰 (b)를 해독한 것**

`http:` + `//` + `[www.lab.cyber.co.kr](http://www.lab.cyber.co.kr)` + `/` + `dir1` + `/` + `file1.html`

www.lab.cyber.co.kr: 웹 서버명

/dir1/file1.html: 데이터 출처(파일)의 경로명

→ `www.lab.cyber.co.kr`이라는 웹 서버에 있는 `/dir1/file1.html`이라는 경로의 파일, 즉 `/dir1/`이라는 디렉토리의 아래에 있는 `file1.html` 파일에 액세스한다는 의미

---

### 3. 파일명을 생략한 경우

****(a) http://www.lab.cyber.co.kr/dir/****

파일명을 생략할 때를 대비하여 파일명을 미리 서버 측에 설정해둠

ex) index.html, default.html

****(b) http://www.lab.cyber.co.kr/****

/라는 디렉토리가 지정되고 파일명 생략

****(c) http://www.lab.cyber.co.kr****

디렉토리명까지 생략

→ 경로명이 아무것도 없는 경우, 루트 디렉토리의 아래에 있는 미리 설정된 파일명의 파일에 액세스

****(d)  http://www.lab.cyber.co.kr/whatisthis****

whatisthis를 파일명으로 보고, whatisthis라는 디렉토리가 있으면 whatisthis를 디렉토리명으로 봄

---

### 4. HTTP의 기본 개념

**HTTP 프로토콜**

: 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것

**HTTP의 동작**

**1) 클라이언트에서 서버를 향해 리퀘스트 메세지를 보냄**

- 무엇을, 어떻게 해서 하겠다는 내용 포함

**URI**는 `무엇을`에 해당

ex) /dir1/file.html, /dir1/program1.cgi, http:~~

→ 다양한 액세스 대상을 쓸 수 있으며, 이러한 액세스 대상을 통칭하는 말이 URI임

**메소드**는 `어떻게 해서`에 해당

- 웹 서버에 어떤 동작을 하고 싶은지를 전달

ex) 클라이언트 측에서 입력한 데이터를 URI로 나타낸 프로그램에 전달하고 싶다는 식의 동작

**2) 리퀘스트 메시지가 웹 서버에 도착하면, 웹 서버는 그 속에 쓰여있는 내용 해독**

- URI와 메시지를 조사하여 무엇을, 어떻게 하는지 판단한 후 요구에 따라 동작하고, 결과 데이터를 응답 메시지에 저장

**스테이터스 코드:** 응답 메시지의 맨 앞부분에 실행 경과가 정상 종료되었는지 또는 이상이 발생했는지 나타냄. ex) 404 Not Found

**3) 헤더 파일과 페이지의 데이터가 이어지고, 이 응답 메시지를 클라이언트에 반송**

**4) 클라이언트에 도착하여 브라우저가 메시지의 안에서 데이터를 추출하여 화면에 표시**


**HTTP의 주요 메소드**

**`GET`:** 보통 웹 서버에 액세스하며 페이지의 데이터를 읽을 때 사용

GET /dir1/file1.html

1) 서버는 dir1/file1.html이라는 파일을 열고 내용의 데이터 추출

2) 추출한 데이터를 응답 메시지에 포함하여 클라이언트에게 반송

3) 클라이언트 측의 브라우저가 이것을 받아 화면에 표시

`**POST**`: 폼에 데이터를 사용해서 웹 서버에 송신하는 경우 사용

1) 리퀘스트 메시지 안에 메시지와 URI를  더불어 CGI 프로그램이나 스크립트에 건네주는 데이터(사용자가 필드에 입력한 값) 사용

2) 메시지가 서버 기계에 도착하면 웹 서버 소프트웨어는 URI에 저장된 애플리케이션 프로그램에게 리퀘스트 메시지의 안에 쓰여있는 데이터를 건네줌

3) 이 프로그램이 출력하는 데이터를 받아서 응답 메시지에 포함시킨 후, 클라이언트에게 반송

`HEAD`: GET과 거의 같음. 하지만, HTTP 메시지 헤더만 반송하고 데이터의 내용을 돌려보내지 않음.

`OPTIONS`: 통신 옵션을 통지하거나 조사할 때 사용

`PUT`: URI로 지정한 서버의 파일을 치환. URI로 지정한 파일이 없는 경우에는 새로 파일을 작성

`DELETE`: URI로 지정한 서버의 파일을 삭제

`TRACE`: 서버 측에서 받은 리퀘스트 라인과 헤더를 그대로 클라이언트에 반송. 프록시 서버 등을 사용하는 환경에서 리퀘스트가 치환되는 상태를 조사할 때 사용

`CONNECT`: 암호화한 메시지를 프록시로 전송할 때 이용하는 메소드

---

### 5. HTTP 리퀘스트 메시지를 만든다

**HTTP 메시지의 포맷**

(a) 리퀘스트 메시지

```
<메소드><공백><URI><공백><HTTP 버전>  —- (가)

<필드명>:<필드값>  —- (나)

…

<공백 행>   —- (나)

<메시지 본문> —- (다)
```

(가): 리퀘스트 라인. 이 한 행으로 리퀘스트의 내용을 대략 알 수 있음

(나): 메시지 헤더. 한 행에 한 개의 헤더 필드를 씀. 이를 통해, 리퀘스트의 부가적인 정보를 나타냄. 행 수는 상황에 따라 달라지며, 공백 행까지가 메시지 헤더가 됨.

(다): 메시지 본문의 내용은 클라이언트에서 서버에 송신하는 데이터. 폼 페이지에 입력한 데이터를 POST 메소드로 웹 서버에 보낼 때 등에 데이터가 들어감.

(b) 응답 메시지

```
<HTTP 버전><공백><스테이터스 코드><공백><응답 문구> --- (가)
<필드명>:<필드값>  --- (나)
...
<공백 행>   --- (나)
<메시지 본문> --- (다)
```

(가): 스테이터스 라인

(나): 메시지 헤더

(다): 메시지 본문으로, 메시지 본문의 내용은 서버에서 클라이언트에 송신하는 데이터. 파일에서 읽은 데이터나 CGI 애플리케이션이 출력한 데이터가 들어감. 메시지 본문은 바이너리 데이터로 취급.

---

### 6. 리퀘스트 메시지를 보내면 응답이 되돌아온다

| 코드값 | 설명 |
| --- | --- |
| 1xx | 처리의 경과 상황 등을 통지 |
| 2xx | 정상 종료 |
| 3xx | 무언가 다른 조치가 필요함을 나타냄 |
| 4xx  | 클라이언트 측의 오류 |
| 5xx | 서버 측의 오류 |

**예시** - html 내 이미지 태그를 포함한 경우

1. 리퀘스트 메시지

```
GET /sample.htm HTTP/1.1
Accept: */*
Accept-Language: ja
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Host: www.lab.glasscom.com
Connection: Keep-Alive
```

1. '/sample1.htm' 의 리스폰스 메시지

```
HTTP/1.1 200 OK
Date: Wed, 7 Oct 2020 13:00:00 GMT
Server: Apache
Last-Modified: Wed, 30 Sep 2020 13:00:00 GMT
ETag: "5a9da-27903c726b61"
Accept-Ranges: bytes
Content-Length: 632
Connection: close
Content-Type: text/html

<html>
<head>
<meta http-equiv-"Content-Type" content="text/html"; charset=utf-8">
<title> 인터넷 탐험 여행</title>
</head>

<body>
<img src="gazou.jpg"/>
</body>
</html>
```

1. '/gazou.jpg' 에 해당하는 리퀘스트 메시지

```
GET /gazou.jpg HTTP/1.1
Accept: */*
Referer: http://www.lab.cyber.co.kr/sample1.htm
Accept-Language: ja
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Host: www.lab.cyber.co.kr
Connection: Keep-Alive
```

1. 리스폰스 메시지

```
HTTP/1.1 200 OK
Date: Wed, 7 Oct 2020 13:00:00 GMT
Server: Apache
Last-Modified: Wed, 30 Sep 2020 13:00:00 GMT
ETag: "5a9da-1913-3aefa236"
Accept-Ranges: bytes
Content-Length: 6419
Connection: close
Content-Type: image/jpeg

바이너리 데이터
```

---

## STORY 02 | 웹 서버의 IP 주소를 DNS 서버에 조회한다

### 1. IP 주소의 기본

**1) HTTP 메시지 만들기**

**2) 메시지를 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신**

→ 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만, 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하여 송신

**3) URL 안에 쓰여있는 서버의 도메인명에서 IP 주소를 조사**

→ OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소로 메시지를 받을 상대를 지정해야 하기 때문

**IP 주소**

TCP/IP는 **서브넷**이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어진다고 생각

- 서브넷: 허브에 몇 대의 PC가 접속된 것이라 생각
- 이것을 한 개의 단위로 생각하여 서브넷이라고 부르는데, 라우터에서 연결하면 네트워크 전체가 완성됨.

→ 허브를 중심으로 몇 대의 컴퓨터가 모여 서브넷을 이루고, 서브넷들은 라우터를 통해 네트워크를 이루게 된다.

**예시)**

ㅇㅇ동 ㅇㅇ번지 라는 형태로 네트워크의 주소를 할당

(동에 해당하는 번호를 서브넷에 할당하고, 번지에 해당하는 번호를 컴퓨터에 할당한 것이 네트워크의 주소)

**네트워크 번호**: 서브넷에 할당된 주소 (동에 해당하는 번호)

**호스트 번호**: 컴퓨터에 할당된 주소 (번지에 해당하는 번호)

**IP 주소**: 네트워크 번호 + 호스트 번호 (이 두 주소를 합친 것)

이 IP 주소에 따라 액세스 대상이 어디에 있는지 판단하고 메시지가 전달됨

1. 송신측 -> 허브
2. 허브 -> 라우터
3. 라우터 -> 라우터
4. 라우터 -> 수신측

**IP 주소의 표기 방법**

**(a) IP 주소 본체의 표기 방법**

`10.11.12.13`

**(b) IP 주소 본체와 같은 방법으로 네트워크를 표기하는 방법**

`10.11.12.13/235.255.255.0`

IP 주소 본체  | 넷마스크

**(c) 네트워크 번호의 비트 수로 넷마스크를 표기하는 방법**

`10.11.12.13/24`

IP 주소 본체 | 넷마스크

**(d) 서브넷을 나타내는 주소**

`10.11.12.0/24`

호스트 번호 부분의 비트가 모두 0인 것은 각 컴퓨터가 아니라 **서브넷** 자체를 나타냄

(e) 서브넷의 브로드캐스트를 나타내는 주소

`10.11.12.255/24`

호스트 번호 부분의 비트가 모두 1인 것은 서브넷 전체에 대한 **브로드캐스트**를 나타냄

넷마스크: 네크워크를 구축할 때 사용자가 직접 내역을 결정할 수 있는데, 이 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧붙이는 정보

호스트 번호 부분이 모두 0인 IP 주소: 각각의 기기를 나타내는 것이 아니라 서브넷 자체를 나타냄

호스트 번호 부분이 모두 1인 IP 주소: 서브넷에 있는 기기 전체에 패킷을 보내는 **브로드캐스트**를 나타냄

---

### 2. 도메인명과 IP 주소를 구분하여 사용하는 이유

TCP/IP의 네트워크는 이 IP 주소로 통신 상대를 지정

→ IP 주소를 모르면 상대에게 메시지 전달 불가

→ OS에 메시지 송신을 의뢰할 때는 IP 주소 조사해야 함

❓URL 안에 도메인명 (서버명)이 아니라 IP주소를 쓰면 좋지 않을까?

IP 주소를 써도 올바르게 작동하지만, IP 주소는 기억하기 어렵기 때문에 URL 안에는 도메인명 (서버의 이름)을 쓰는 것이 좋음

❓IP 주소 대신 도메인명을 사용하지 않는 이유

도메인명은 수십 bytes ~ 255 bytes 를 차지함

→ 라우터에 과부하가 걸림

→ 사람은 도메인명, 라우터는 IP 주소를 사용

**DNS:** 이름을 알면 IP 주소를 알 수 있다거나 IP 주소를 알면 이름을 알 수 있다는 원리를 사용하여 양쪽의 차이를 해소

---

### 3. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다

>
>

**DNS 서버를 어떻게 조회할 수 있을까?**

네임 리졸루션(name resolution, 이름 확인)

- DNS 원리를 사용하여 IP 조사하는 것

DNS 리졸버

- DNS 클라이언트
- 네임 리졸루션을 실행하는 주체
- Socket 라이브러리 내의 하나의 프로그램
    - Socket 라이브러리 : 네트워크 기능 호출을 위한 프로그램 라이브러리

---

### 4. 리졸버를 이용하여 DNS 서버를 조회한다

리졸버는 애플리케이션에서 Socket 라이브러리를 통해 간단히 호출이 가능함

예를 들어

```
<애플리케이션 프로그램의 이름> (<매개변수>)
{
  ...
  <메모리 영역> = gethostbyname("www.lab.cyber.co.kr");\
  ...
  <HTTP 메시지 송신>
}
```

브라우저는 이런 형태로 리졸버를 이용해 IP 주소를 얻고 웹 서버에 메시지를 보냄

---

### 5. 리졸버 내부의 작동

1. 브라우저가 리졸버를 호출하면 제어가 리졸버의 내부로 넘어감
2. 리졸버는 DNS 에 문의하기 위한 메시지를 만듦
3. 리졸버는 직접 메시지를 송신하는 기능을 가지고 있는 것이 아니기 때문에,  OS의 **프로토콜 스택**을 호출하여 실행을 의뢰
4. 프로토콜 스택이 LAN 어댑터를 통해 DNS 서버로 메시지를 송신
5. DNS 서버가 IP 주소를 조회해 응답메시지를 보내줌

❓DNS 서버의 IP 주소는 어떻게 아는 것일까?

TCP/IP 설정 항목의 하나하나로 컴퓨터에 미리 설정되어 있음


---
## STORY 03 | 전 세계의 DNS 서버가 연대한다

### 1. DNS 서버의 기본 동작

클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답함

리졸버로부터 DNS 서버가 받는 조회 메시지에는 다음과 같은 내용이 포함되어 있음

**조회 메시지 구성 요소**

- 이름
  - 서버나 메일 배송 목적지와 같은 이름
- 클래스
  - 인터넷 이외에서의 네트워크 이용까지 검토하여 이것들을 식별하기 위한 정보였음. 하지만, 현재는 인터넷 이외의 네트워크는 소멸되어 `IN` 값만 사용하고 있음
- 타입
  - 이름에 어떤 타입(종류)의 정보가 지원되는지를 나타냄
  - A : IP 주소 지원, MX : 메일 배송 목적지 지원

DNS 서버에는 이들 세 가지 정보에 대응하여 클라이언트에 회답하는 항목을 등록

| 이름 | 클래스 | 타입 | 클라이언트 회답하는 항목 |
| --- | --- | --- | --- |
| http://www.lab.cyber.co.kr/ | IN | A | 192.0.2.226 |
| cyber.co.kr | IN | MX | 10 mail.cyber.co.kr |
| mail.cyber.co.kr | IN | A | 192.0.2.227 |

이러한 항목들을 하나씩 **리소스 레코드**라고 부름

따라서, DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답

### 2. 도메인의 계층

위에서는 조회 메시지를 받은 DNS 서버에 해당 정보가 등록되어 있는 경우를 가정하고 설명했음. 하지만, 인터넷에는 막대한 수의 서버가 있으므로 이 전부를 1대의 DNS 서버에 등록하는 것은 불가능함.

→ 조회 메시지를 받은 DNS 서버에 정보가 등록되어 있지 않은 경우를 살펴봄..

인터넷에는 DNS 서버가 수만대가 있으므로 일일이 모든 DNS 서버들을 찾아갈 수 없음.

→ DNS 서버는 **계층적 구조**를 가지고 있음.

ex) [www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) (점으로 계층을 구분)

- kr 도메인
- co 도메인
- cyber 도메인
- lab 도메인
- www 도메인

### 3. 담당 DNS 서버를 찾아 IP 주소를 가져온다

lab.glasscom.com이라는 도메인을 담당하는 DNS 서버를 glasscom.com의 DNS 서버에 등록

glasscom.com의 DNS 서버를 com 도메인의 DNS 서버에 등록

→ 상위의 DNS 서버에 가면 하위의 DNS 서버의 IP 주소를 알 수 있고, 거기에서 조회 메세지를 보낼 수 있음

`kr`과 `com`같은 도메인을 **최상위 도메인**이라고 부름.

- 최상위 도메인을 연결하는 루트 도메인 존재

→ www.lab.glasscom.com. 처럼 끝에 마침표를 찍어서 **루트 도메인**을 나타냄

→ 루트 도메인에서 차례로 아래쪽으로 거슬러 내려감


**`www.lab.glasscom.com`이라는 웹 서버에 관한 정보 조회**

1. PC 에 등록되어 있는 가까운 DNS 서버에 조회 메시지를 전송
2. 해당 DNS 서버에는 등록되어 있지 않으므로, 루트 도메인부터 조회 시작. 루트에도 등록 되어 있지 않아 하위 도메인인 `com` 도메인의 DNS 서버의 IP 주소를 응답
3. `com` DNS 서버에도 등록되어 있지 않아, 하위 도메인인 `glasscom` DNS 서버 IP 주소 응답
4. `glasscom` DNS 서버에도 등록되어 있지 않아, 하위 도메인인 `lab` DNS 서버 IP 주소 응답
5. `lab` DNS 서버에도 등록되어 있지 않아, 하위 도메인인 `www` DNS 서버 IP 주소 응답
6. `www` DNS 서버에 최종적으로 `www.lab.glasscom.com`에 대한 IP 주소가 등록되어 있어 해당 웹 서버 IP 주소 응답
7. 최초로 조회 메시지를 받은 가장 가까운 DNS 서버는 이 IP 주소를 클라이언트에 응답
8. 웹 서버에 접근

### 4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다

- DNS 서버는 한번 조사한 이름은 캐시에 기록할 수 있다.
- 캐시에 기록되어있으면 그 정보를 응답해 더 빠르게 동작
- 조회한 이름이 존재하지 않는다는 것도 캐시 가능

주의할 점
- 캐시에 저장한 후 등록 정보가 변경되는 경우 캐시정보는 잘못된 정보가 됨
- 따라서, 캐시에 저장할 때 유효기간을 설정
- 또한, 응답시 캐시 정보인지 등록처 DNS 서버에서 응한 것인지 알려줌

## STORY 04 | 프로토콜 스택에 메시지 송신을 의뢰한다

### 1. 데이터 송수신 동작의 개요

IP 주소를 조사했으면 IP 주소의 상대, 웹 서버에 메시지를 송신하도록 OS 내부에 있는 **프로토콜 스택** 에 의뢰

통신을 위해서는 클라이언트와 서버 사이를 일종의 파이프로 연결하는 작업이 필요. 이 때, 그 양 끝의 출입구를 **socket (소켓)**이라고 부름. 따라서 이 소켓을 만들고 연결을 하게 됨

**데이터 송수신 동작**

1. 소켓을 만듦 (소켓 작성 단계)
2. 서버측의 소켓에 파이프를 연결 (접속 단계)
3. 데이터를 송수신 (송수신 단계)
4. 파이프를 분리하고 소켓을 말소 (연결 끊기 단계)

Socket 라이브러리의 프로그램 부품을 이용하여, 이 단계들을 수행하게 되는데 실제로 이 프로그램 부품들은 메시지 내용을 그대로 프로토콜 스택에 전달하는 중개역을 수행하고 실질적인 작업은 하지 않음

프로토콜 스택이 어떻게 파이프를 연결하고 데이터를 송수신 하는지는 차후에 설명 (2장)

### 2. 소켓의 작성 단계

이 단계에서는 Socket 라이브러리 안의 *socket* 이라는 프로그램 부품만 호출하면 됨. *socket*을 호출하면 그 내부에 제어가 넘어가 소켓을 만드는 동작을 실행하고 그 후 애플리케이션으로 제어가 돌아온다. (socket의 내부 동작은 2장에서...)

소켓이 생성되면 디스크립터라는 것이 생성되고 이 디스크립터는 애플리케이션에서 메모리에 기록을 해둠.

디스크립터

- 소켓을 식별하게 해주는 식별자 역할
- 컴퓨터 내부에서는 복수의 데이터 송수신 동작이 진행될 수 있으므로, 소켓들이 여러 개 생기고 이 소켓들을 구별할 필요가 있음
- ex) 브라우저에서 2개의 창을 띄워 다른 페이지에 접근하게 될 때

### 3. 파이프를 연결하는 접속 단계

다음으로 만든 소켓을 서버측의 소켓과 접속하도록 프로토콜 스택에 의뢰하게 됨. 이 때 애플리케이션은 Socket 라이브러리의 *connect*라는 프로그램 부품을 호출하여 이 의뢰동작을 실행. connect 프로그램을 실행할 때에는 필요한 것이 3가지가 있음.

1. 디스크립터
  - 소켓 생성시 만들어진 디스크립터
2. 서버 IP 주소
3. 포트 번호

**포트 번호**

IP 주소의 경우는 네트워크에 존재하는 각 컴퓨터를 식별할 수 있는 값이고, 포트 번호는 그 컴퓨터의 소켓을 식별하는 값

디스크립터와의 차이

- 디스크립터는 소켓을 만들도록 의뢰한 애플리케이션에게 건네주는 값이지, 접속 상대에 건네주는 것이 아님
- 접속 상대 측은 그 값을 모름
- 따라서, 서버 측 소켓의 디스크립터는 클라이언트에서 알 수 없음

(포트 번호는 접속 상대 측에서 소켓을 식별하기 위해 사용)

서버 측의 포트 번호

- 서버 측의 포트 번호는 애플리케이션 종류에 따라 미리 결정된 값을 사용한다는 규칙이 있음
- ex) 웹 : 80, 443 메일: 25 (자세한 사항은 6장에서...)

웹 서버 측에서의 클라이언트 포트 번호 식별 방법

- 소켓을 만들 때 프로토콜 스택이 적당한 포트 번호 값을 할당하고, 접속 동작을 실행할 때 서버 측에 알려줌.

### 4. 메시지를 주고받는 송수신 단계

소켓이 준비가 되면 데이터를 보낼 준비가 완료된 것

애플리케이션은 송신 데이터(HTTP 리퀘스트 메시지)를 메모리에 준비

송신 과정

- 송신을 위해 Socket 라이브러리의 *write*라는 프로그램 부품을 사용하여 프로토콜 스택에 송신 동작 의뢰
- 이 때는 디스크립터와 송신 데이터를 지정 (소켓에 이미 상대와 연결되어 있으므로 디스크립터만 사용)
- 송신 데이터는 네트워크를 통해 서버에 도착
- 서버는 수신 데이터를 처리하고 응답 메시지를 보냄

수신 과정

- Socket 라이브러리의 *read* 프로그램 부품을 통해 프로토콜 스택에 수신 동작을 의뢰
- 수신 응답 메시지를 **수신 버퍼**라는 메모리 영역에 저장 - 애플리케이션 내부에 위치

### 5. 연결 끊기 단계에서 송수신이 종료된다

브라우저가 데이터 수신을 완료하면 송수신 동작이 끝남.

Socket 라이브러리의 close 라는 프로그램 부품을 호출하여 프로토콜 스택에 의뢰

연결 끊는 과정
- 웹 서버 측은 응답 메시지의 송신을 완료했을 때, 먼저 close를 호출하여 연결을 끊음
- 이것이 클라이언트 측에 전달되고, 클라이언트 소켓은 연결 끊기 단계로 들어감
- 브라우저가 read로 수신 동작을 의뢰했을 때, 수신한 데이터를 건네주는 대신 송수진 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에 통지 (이로써 송수신이 종료되었다는 것을 알 수 있음)
- 브라우저에서도 close를 호출하여 연결 끊기 단계에 들어감