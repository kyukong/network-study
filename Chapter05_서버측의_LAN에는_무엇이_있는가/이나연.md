# Chapter_05 서버측의 LAN에는 무엇이 있는가? _ 방화벽과 캐시 서버의 탐험

## STORY 01 | 웹 서버의 설치 장소

### 1. 사내에 웹 서버를 설치하는 경우

1) 라우터에서 직접 연결하는 경우

사내의 LAN에 서버를 설치하고, 인터넷에서 직접 액세스

문제점

- IP 주소의 부족
    - 사내 LAN에 설치한 기기에는 서버뿐만 아니라 클라이언트에도 글로벌 주소를 할당해야 하는데, 지금은 클라이언트에 글로벌 주소를 할당할 여유가 없음
- 보안상의 이유
    - 인터넷에서 도착하는 패킷을 차단하는 것이 아니며, 서버는 노출 상태로 공격자의 눈 앞에 방치됨
    - 서버 자체의 방어를 강화하는 방법도 있지만, 사소한 설정 실수 등으로 보안 구멍이 생길 수 있음

→ 이전에는 이런 형태로 서버를 설치하는 경우가 많았지만, 현재 이 방법은 주류에서 밀려남

2) 방화벽으로 분리하는 경우

방화벽을 두는 방법이 일반화됨

- 방화벽은 관문의 역할. 특정 서버에서 동작하는 특정 애플리케이션에 액세스하는 패킷만 통과시키고, 그 외의 패킷을 차단하는 역할을 함.
- 외부에서의 액세스가 허가되지 않은 애플리케이션으로 갈 패킷은 차단되므로 여기에 보안 구멍이 있어도 공격받은 패킷이 도착하지 않음

문제점

- 액세스를 허가한 애플리케이션에 보안 구멍이 있으면 공격받을 위험성 남아있음

→ 하지만, 보안이 전부 무방비 상태가 되는 것에 비하면 위험성이 크게 낮아짐

### 2. 데이터센터에 웹 서버를 설치하는 경우

3) 통신 회사의 데이터센터에 설치하는 경우

데이터센터

- 프로바이더의 중심 부분에 있는 NOC에 직접 접속되었거나 프로바이더들이 상호 접속하는 IX에 직결되어 있음
    - 인터넷의 중심 부분에 고속 회선으로 접속되었으므로 여기에 서버를 설치하면 고속으로 액세스할 수 있음

  → 서버에 대한 액세스가 증가했을 때 효과적

- 내진 구조의 건물에 설치하거나, 자가 발전 장치를 비치하거나, 24시간 입실과 퇴실이 관리되는 곳이 많으므로, 회사 안보다 안전성이 높음
- 기기의 가동 상태 감시, 방화벽의 설치 운영, 부정 침입 감시라는 부가 서비스를 제공하는 경우가 있음

인터넷의 중심 부분에서 데이터센터로 패킷이 흘러가고, 여기에서 서버 머신에 도착.

→ 어느 경우든지 패킷은 라우터에서 중게되고 최종적으로 서버에 도착한다는 점은 달라지지 않음

## STORY 02 | 방화벽의 원리와 동작

### 1. 패킷 필터링형이 주류이다

서버의 설치 장소와 관계 없이 지금은 바로 앞에 방화벽이 있는 것이 보통임

네트워크에는 다양한 종류의 패킷이 많이 흐름

→ 통과시킬 패킷과 차단할 패킷을 선별하는 다양한 방법이 고안됨

→ 성능, 가격, 사용 편의성 드으이 이유로 **패킷 필터링형**이 가장 많이 보급됨

### 2. 패킷 필터링의 조건 설정 개념

인터넷에서 웹 서버에 대한 액세스를 허가하지 않으면, 서버에서 인터넷의 액세스를 금지하도록 패킷을 차단

- 이전에는 웹 서버에서 인터넷측에 대한 액세스를 금하는 예가 적었음.
- 하지만, 지금은 서버에 기생하며 여기에서 다른 서버에 감염되어 가는 부정 소프트웨어가 있으므로 감염을 막기 위해 웹 서버에서 인터넷측에 액세스하는 것을 금지하고 있음.

패킷 필터링 조건 설정

- 수신처 IP 주소와 송신처 IP 주소에 따라 시점과 종점 판단
- 인터넷에서 보내오는 패킷은 시점을 지정할 수 없지만, 흐름의 종점은 웹 서버가 되므로 이것을 조건으로 설정하고 조건에 해당하는 패킷만 통과시킴
- 종점(수신처 IP 주소)이 웹 서버의 IP 주소에 일치하는 패킷은 통과시킨다는 조건 설정
- 송신처 IP 주소에 따라 시점을 지정할 수 있으면 이것도 조건에 추가 (송신처 IP 주소를 조건으로 지정하지 않아도 상관없음)
- 웹 서버에서 인터넷측으로 흐르는 패킷도 마찬가지로 설정

→ 수신처나 송신처의 주소에 따라 패킷이 어디서, 어디로 흘러가는지를 판단하여 통과시킬 것인지, 차단할 것인지 결정

### 3. 애플리케이션을 한정할 때 포트 번호를 사용한다

위에서 설명한 것만 설정한다면, 인터넷과 웹 서버 사이를 흐르는 패킷은 전부 통과해서 위험한 상태가 됨

es) 서버 머신에서 파일 서버 기능이 유효하므로 네트워크를 경유하여 파일에 부정으로 액세스할 경우 정보가 누설될 수 있음

→ 애플리케이션을 한정함

애플리케이션 한정

- TCP 헤더나 UDP 헤더에 기록되어 있는 포트 번호를 조건으로 추가

### 4. 컨트롤 비트로 접속 방향을 판단한다

웹 서버에서 인터넷측에 액세스하는 동작을 정지시킬 수 없기 떄문에, 아직 조건이 부족

- 단순히 웹 서버에서 인터넷으로 흐르는 패킷을 정지시키면 인터넷에서 웹 서버에 액세스하는 동작도 정지됨

→ 패킷이 흐르는 방향이 아니라 액세스 방향을 판단하여 동작 정지

→ TCP 헤더에 있는 컨트롤 비트

허가하는 액세스 동작에서 흐르는 패킷과 그 외의 패킷을 완전히 선별할 수 있을 때까지 조건을 추가

액세스를 허가하는 패킷만 통과시키고, 그 외는 차단하도록 조건을 설정

DNS 서버에 대한 액세스

- 통과시키는 것과 차단하는 것을 완전히 선별할 수 없음
- DNS 서버에 조회하는 동작은 UDP를 사용하는데, UDP는 TCP와 달리 접속 단계의 동작이 없으므로 TCP처럼 컨트롤 비트에 의해 액세스 방향을 판별할 수 없음

→ DNS 서버에 액세스하는 것을 허가하고, 인터넷에서 사내의 DNS 서버에 액세스하는 패킷은 차단한다는 조건을 설정할 수 없음

- UDP를 사용하는 애플리케이션에서 이 점은 모두 공통임

→ 어느 정도 위험을 각오한 상태에서 애플리케이션의 패킷을 전부 통과시키거나, 불편을 감수하고 애플리케이션을 전면적으로 차단하는 방법 선택해야 함.

### 5. 사내 LAN에서 공개 서버용 LAN으로 조건을 설정한다

ex) 사내 LAN과 공개 서버용 LAN 사이를 자유로이 왕래할 수 있도록, 수신처 IP 주소가 공개 서버용 LAN과 일치하는 패킷을 전부 통과시켰다고 가정.

if, 송신처 IP 주소를 조건으로 설정하지 않으면, 인터넷측에서 흘러온 패킷이 무조건 공개 서버용 LAN에 유입됨.

→ 공개 서버용 LAN에 설치한 서버 전부가 위험한 상태에 빠지므로, 신중하게 조건 설정해야 함

### 6. 밖에서 사내 LAN으로 액세스할 수 없다

패킷 필터링형 방화벽은 주소 변환의 기능도 가지고 있으므로 설정이 필요함.

→ 인터넷과 사내 LAN을 왕래하는 패킷은 주소 변환을 해야 하므로 설정 필요

주소 변환을 이용하면, 인터넷측에서 사내 LAN에는 액세스할 수 없게 됨

→ 사내 LAN에 대한 액세스를 금지하도록 패킷 필터링의 조건을 설정할 필요가 없음

### 7. 방화벽을 통과한다

- 방화벽은 여러 가지 조건이 설정되어 있어, 조건에 해당하는지 판단하고, 통과시킬지와 차단할지를 결정함.
- 판정한 후, 차단하는 대상이 되면 패킷을 버리고, 버린 기록을 남김

→ 버린 패킷 중에는 부정 침입의 흔적을 나타내는 것이 있으므로, 이것을 분석하여 침입자의 수법을 밝히거나 향후 부정 침입 대책에 도움이 될 수 있음

- 통과시킨다는 판정을 내린 경우에는, 패킷을 중계

→ 라우터의 동작과 같음.

- 통과시킨다고 결정되면 그 이상의 특별한 구조는 없음.

→ 패킷 필터링이라는 구조는 방화벽용의 특별한 구조라고 생각할 게 아니라, 라우터의 패킷 중계 기능 중에서 부가 기능이라고 생각하면 좋음

- 판정 조건이 복잡해지면 라우터의 명령으로 설정하기가 어려워지고, 패킷을 버린 기록을 남기는 것도 라우터에 크게 부담스러운 큰 작업이기 때문에, 전용 하드웨어나 소프트웨어 사용.
- 복잡한 조건 설정이나 버린 패킷의 기록이 필요하지 않으면, 패킷 필터링 기능을 가진 라우터를 방화벽으로 사용할 수 있음

패킷 필터링형 방화벽은 수신처 IP 주소, 송신처 IP 주소, 수신처 포트 번호, 송신처 포트 번호, 컨트롤 비트 등으로 패킷을 통과시킬지 판단함.

### 8. 방화벽으로 막을 수 없는 공격

패킷 흐름의 시점과 종점만 보고 위험한 패킷을 전부 판단할 수 있는 것은 아님.

ex) 특수한 데이터를 포함한 패킷을 받으면 웹 서버가 다운되는 상황

- 방화벽은 종점과 시점만 조사
- 패킷 중에 특수한 데이터가 있어도, 신경쓰지 않고 패킷을 통과시킴
- 패킷이 웹 서버에 도착하면, 웹 서버는 다운됨

→ 패킷의 내용을 조사하지 않으면, 위험한지 판단할 수 없어서 방화벽의 구조는 이러한 상황에 대처할 수 없게 됨

대처법

1) 웹 서버 소프트웨어의 버그를 고쳐서 다운되지 않게 하는 것

- 보안 구멍 정보를 수집하여, 항상 새로운 버전으로 갱신하는 것 중요

2) 패킷의 내용을 조사하여 위험한 데이터가 포함되어 있는 경우, 패킷을 차단하도록 장치나 소프트웨어를 방화벽과는 별도로 준비

- 패킷의 내용이 위험한지는 웹 서버에 버그가 있는지 여부로 결정
- 잠재적인 버그가 있어도, 버그가 발견되지 않은 경우에는 패킷이 위험하다고 판단할 수 없기 때문에 패킷을 차단할 수 없음

→ 미지의 위험성에는 대처할 수 없음. 발견된 버그를 고치는 방법과 크게 다르지 않음.

하지만, 여러 대의 서버가 있는 경우에는 새로운 버전으로 바꾸기를 미루거나 잊어버리기 쉬우므로 패킷의 내용을 검사하는 방법은 효과가 있음

## STORY 03 | 복수 서버에 리퀘스트를 분배한 서버의 부하 분산

### 1. 처리 능력이 부족하면 복수 서버로 부하 분산된다

서버에 액세스가 증가할 때, 서버로 통하는 회선을 빠르게 하는 것만으로 부족한 경우 있음

ex) CGI 등의 애플리케이션에서 페이지의 데이터를 동적으로 만드는 경우, 서버 머신의 프로세서 파워를 사용하기 때문에 더욱 중요

- 서버 머신을 고성능 기종으로 교체
    - 다수의 사용자가 집중적으로 액세스하면, 한 대로는 따라잡지 못할 수 있음
- 복수의 서버를 사용 (**분산 처리**)
    - 서버 한 대당 처리량을 줄임

여러 대의 웹 서버를 설치하고 한 대가 담당하는 사용자 수를 줄이는 방법

- 클라이언트가 보내는 리퀘스트를 웹 서버에 분배하는 구조가 필요

  ex) DNS 서버에서 분배하는 방법

    - DNS 서버에 같은 이름으로 여러 대의 웹 서버를 등록해 놓으면 DNS 서버는 조회가 있을 때마다 차례대로 IP 주소를 되돌려줌

  [www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) 이라는 서버명에 대해

  192.0.2.60

  192.0.2.70

  192.0.2.80 이라는 3개의 IP 주소를 대응시킨다고 가정

  192.0.2.60 | 192.0.2.70 | 192.0.2.80

  192.0.2.70 | 192.0.2.80 | 192.0.2.60

  192.0.2.80 | 192.0.2.60 | 192.0.2.70

  으로 차례대로 회답

  → 라운드 로빈

  복수의 서버에 균등하게 액세스 분산시킬 수 잇음

  문제점

    - 웹 서버가 정지해도 상관하지 않고 IP 주소를 회답해 버림 (보통 DNS 서버는 웹 서버가 동작하지 않는지 확인하지 못하기 때문)
    - 웹 서버가 변하면 대화가 도중에 끊길 수 있음

      ex) 쇼핑 사이트에서 첫 번째 페이지에 주소나 성명을 입력하고, 두 번째 페이지에서 신용카드 번호를 입력하는 것



### 2. 부하 분산 장치를 이용해 복수의 웹 서버로 분할된다

위의 상태를 피하기 위해 부하 **분산 장치** 또는 **로드 밸런서** 등으로 부르는 기기 고안됨

부하 분산 장치 사용

- 부하 분산 장치를 웹 서버 대신 DNS 서버에 등록
- 부하 분산 장치에 www.lab.cyber.co.kr과 같은 이름을 붙이고, 그 이름에 대응하여 부하 분산 장치의 IP 주소를 DNS 서버에 등록함
- 클라이언트는 부하 분산 장치를 웹서버라고 생각하여, 여기에 리퀘스트 메시지를 보내야 할지 판단하고, 웹 서버에 리퀘스트를 전송

→ 어느 웹 서버에 리퀘스트를 전송해야 할지 판단 근거?

웹 서버의 부하 상태

대화가 복수 페이지에 걸쳐있을 때, 웹 서버의 부하와 관계 없이 이전의 리퀘스트와 같은 웹 서버에 전송해야 함.

→ 대화가 복수 페이지에 걸쳐있는지 판단

- HTTP의 사양을 확장하여 전후 관계를 판단하기 위한 정보를 HTTP 헤더 필드에 부가
- 부하 분산 장치는 이러한 정보를 조사 후, 일련의 동작이라면 이전과 같은 웹 서버에 리퀘스트를 전송하고, 그렇지 않으면 부하가 적은 웹 서버에 전송하도록 동작

## STORY 04 | 캐시 서버를 이용한 서버의 부하 분산

### 1. 캐시 서버의 이용

캐시 서버: 프록시라는 구조를 사용하여 데이터를 캐시에 저장하는 서버

프록시

- 웹 서버에 대한 액세스 동작을 중개하는 역할
- 액세스 동작을 중개할 때, 웹 서버에서 받은 데이터를 디스크에 저장해두고 웹 서버를 대신하여 데이터를 클라이언트에 반송하는 기능 → 캐시라 부름

캐시에 데이터를 저장한 후, 웹 서버 측에서 데이터가 변경되면 캐시의 데이터 사용할 수 없음

### 2. 캐시 서버는 갱신일로 콘텐츠를 관리한다

캐시 서버의 동작

1) 캐시 서버를 웹 서버 대신 DNS 서버에 등록

2) 사용자가 캐시 서버에 HTTP의 리퀘스트 메시지를 보냄

3) 캐시 서버가 메시지를 받음

4) 리퀘스트 메시지를 받으면, 캐시 서버는 리퀘스트 메시지의 내용을 조사하고 데이터가 자신의 캐시에 저장되었는지 조사

**데이터가 캐시에 저장되어 있는 경우**

5) 웹 서버측에서 데이터가 변경되었는지 조사하기 위한 If-Modified-Since라는 헤더 필드를 추가하여 웹 서버에 전송

6) 헤더 필드의 값과 페이지 데이터의 최종 갱신 일시를 비교하여 변경이 없으면, 변경이 없는 것을 나타내는 응답 메시지 반송

**데이터가 캐시에 저장되어 있지 않은 경우**

5) 캐시 서버는 리퀘스트 메시지에 Via라는 헤더 필드(캐시 서버를 경유한 것을 나타냄)를 추가하여 웹 서버에 리퀘스트 전송

6) 응답 메시지를 캐시에 저장하고 저장한 일시 기록

웹 서버측에서 데이터가 변경된 경우에는 캐시에 데이터가 저장되어 있지 않은 경우와 같음

### 3. 프록시의 원점은 포워드 프록시이다

포워드 프록시

- 클라이언트측에 캐시 서버를 두는 방법
- 프록시 서버라는 항목에 포워드 프록시의 IP 주소를 설정함
  - 포워드 프록시를 설정하면 http://…라는 URL을 그대로 리퀘스트의 URL에 기록
  - 서버측에 두는 캐시 서버와 같이 전송 대상의 웹 서버를 사전에 설정해 둘 필요가 없고, 모든 웹 서버에서 전송할 수 있음

프록시는 리퀘스트의 내용을 조사한 후 전송하므로 리퀘스트의 내용에 따라 액세스가 가능한지 판단할 수 있음

### 4. 포워드 프록시를 개량한 리버스 프록시

포워드 프록시를 사용할 경우, 브라우저에 대한 설정이 꼭 필요함

브라우저의 설정이 잘못됐을 경우, 장애의 원인이 됨

→ 웹 서버의 바로 앞에 프록시를 두는 방법 선택하지 않음

→ **리버스 프록시** 사용

### 5. 트랜스페어런트 프록시

트랜스페어런트 프록시

- 리퀘스트 메시지에서 패킷의 헤더를 조사하는 방법
- 패킷의 맨 앞에 있는 IP 헤더에는 수신처 IP 주소가 기록되어 있으므로, 이것을 조사하면 액세스 대상 웹 서버가 어디에 있는지 알 수 있음
- 전송 대상을 캐시 서버에 설정할 필요가 없고, 어느 웹 서버에서나 전송할 수 있음

트랜스페어런트 프록시는 DNS 서버에 등록하는 것이 없음

→ 웹 서버로 리퀘스트 메시지가 흘러가는 길에 트랜스페어런트 프록시 설치

## STORY 05 | 콘텐츠 배포 서비스

### 1. 콘텐츠 배포 서비스를 이용한 부하 분산

캐시 서버는 서버 측에 두는 경우와 클라이언트에 두는 경우가 이용 효과 면에서 차이가 남

서버 측: 웹 서버의 부하를 경감하는 효과는 있지만, 인터넷을 흐르는 트래픽을 억제하는 효과는 없음

→ 클라이언트 측에 캐시 서버가 있으면, 이러한 혼잡에 휘말려드는 일이 없으므로 패킷의 흐름이 안정됨

→ 큰 화상이나 영상 같은 대용량 데이터를 포함하는 콘텐츠 유용

하지만, 클라이언트 측에 두는 캐시 서버는 클라이언트 측의 네트워크를 운영 관리하는 사람이 소유하므로 웹 서버 운영자가 제어할 수 없음

→ 프로바이더와 계약하여 웹 서버 운영자가 제어할 수 있는 캐시 서버를 클라이언트 측의 프로바이더에 두는 방법

- 인터넷의 어디에서 액세스하는지 알 수 없음
  - 프로바이더의 POP 전부에 캐시 서버를 설치해야 함.. 수가 너무 많으므로 비현실적

  → 중요한 프로바이더에 중점을 둠

  - 웹 서버 운영자가 프로바이더와 계약하여 캐시 서버를 설치하는 것은 비용면에서나 노력면에서 큰일임.

  → 콘텐츠 배포 서비스 (캐시 서버를 설치하고, 이걸 웹 서버 운영자에게 대출하는 서비스)


CDSP (Content Delivery Service)

- 중요한 프로바이더와 계약하고 그곳에 다수의 캐시 서버를 설치
- 웹 서버 운영자와도 계약하여 웹 서버와 CDSP의 캐시 서버를 연대시킴

캐시 서버는 다수의 웹 서버의 데이터를 캐시에 저장할 수 있으므로 CDSP가 설치한 캐시 서버를 다수의 웹 서버 운영자가 공동으로 이용할 수 있음

→ 웹 서버 운영자의 한 회사당 비용을 절감할 수 있음

→ 프로바이더와의 계약은 CDSP가 한 번에 인수하므로 노력면에서도 웹 서버 운영자에 부담이 되지 않음

### 2. 가장 가까운 캐시 서버의 관점

콘텐츠 배포 서비스를 사용하는 경우, 인터넷 전체에 설치된 다수의 캐시 서버 이용

→ 다수가 있는 캐시 서버 중에서 가장 가까운 캐시 서버를 찾아내고, 클라이언트가 여기에 액세스하도록 중재하는 구조 필요

- 복수 서버를 설치하여 부하를 분산시킬 떄 DNS 서버에서 액세스를 분배하는 것과 비슷한 방법
  - DNS 서버가 웹 서버의 IP 주소를 회답할 때 가장 가까운 캐시 서버의 IP 주소를 회답하도록 DNS 서버를 세밀하게 설정

### 3. 리피터용 서버로 액세스 대상을 분배한다

리다이렉트: 다른 웹 서버에 액세스하도록 처리하는 것

- 리다이렉트에 의해 가장 가까운 캐시 서버를 클라이언트에 통지할 떄는 리다이렉트용 서버를 웹 서버측의 DNS 서버에 등록
- 클라이언트는 여기에 HTTP의 리퀘스트 메시지를 보냄
- 리다이렉트용 서버에는 DNS 서버와 같이 라우터에서 모은 경로 정보가 있으며, 여기에서 가장 가까운 캐시 서버를 찾음
- 캐시 서버를 나타내는 Location 헤더를 붙여 응답을 돌려보내면 클라이언트는 캐시 서버에 다시 액세스
  - 장점: 리다이렉트는 클라이언트가 보내는 HTTP 메시지의 송신처 IP 주소를 바탕으로 거리를 판단하므로 정밀도가 높음
  - 패킷의 왕복 시간을 통해 캐시 서버까지의 거리를 계산하여 최적의 캐시 서버에 액세스하도록 스크립트 프로그램을 내장한 페이지를 반송하는 방법도 있음

  → 클라이언트 스스로 최적의 캐시 서버를 판단하고, 여기에 액세스할 수 있음


### 4. 캐시 내용의 갱신 방법에서 성능의 차이가 난다

- 한 번 액세스한 데이터를 저장해 두고, 이것을 두 번째 이후의 액세스 동작에 이용
  - 최초의 액세스 동작에 도움이 되지 않음
  - 두 번째 이후의 액세스에서도 원래 데이터를 가진 웹 서버에 갱신된 내용의 유무를 확인한다는 동작이 있기 때문에, 이것이 혼잡하게 뒤얽히면 응답 시간이 악화됨

  → 웹 서버에서 원래 데이터를 갱신할 경우 이것을 즉시 캐시 서버에 반영해야 함

  - 캐시의 데이터는 항상 최신의 상태를 유지할 수 있으므로, 원래 데이터의 갱신을 확인할 필요가 없음
  - 최초의 액세스 동작에도 캐시의 데이터 이용할 수 있음

  → 콘텐츠 배포 서비스에 이용하는 캐시 서버에는 이러한 대책 내장되어 있음


동적으로 페이지를 만드는 경우, 캐시 서버에 데이터를 저장해 두면 안 됨

→ 페이지 전체를 캐시에 저장하지 않고 애플리케이션에서 만든 부분을 구분하고, 변하지 않는 부분만 캐시에 저장