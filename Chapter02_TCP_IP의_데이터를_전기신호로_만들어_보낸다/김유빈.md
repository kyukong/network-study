# STORY 01 소켓을 작성한다

## 1. 프로토콜 스택의 내부 구성

- 네트워크 어플리케이션에서 OS 에 통신을 요청하면 다음과 같은 흐름으로 처리된다.
    - 어플리케이션(Socket 라이브러리) → OS(프로토콜 스택) → 드라이버 소프트웨어 → 하드웨어
    - TCP : 브라우저나 메일 등의 일반적인 어플리케이션이 데이터를 송수신하는 경우
    - UDP : DNS 서버에 대한 조회 등의 짧은 제어용 데이터를 송수신하는 경우
- IP 프로토콜은 패킷 송수신 동작을 제어하는 부분이다.
    - 인터넷 상에서 데이터를 송수신할 때 `패킷` 이라는 작은 단위의 형태로 운반한다.
    - ICMP : 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지하는 경우
    - ARP : IP 주소에 대응하는 이더넷의 MAC 주소를 조사하는 경우
- LAN 드라이버는 LAN 어댑터의 하드웨어를 제어한다.
- LAN 어댑터는 케이블에 대해 신호를 송수신하는 동작을 수행한다.

## 2. 소켓의 실체는 통신 제어용 제어 정보

- 소켓은 물리적으로 존재하는 것이 아닌 개념적인 정보를 의미한다.
    - 소켓 = 송수신하기 위한 제어 정보
    - 통신 상대의 IP, PORT, 통신 진행 상태, 응답 수신 여부, 송신 후 경과 시간 등
- 프로토콜 스택은 소켓에 기록되 제어 정보를 참조하며 진행한다.

## 3. Socket 을 호출했을 때의 동작

- 소켓을 생성한다.
    - 소켓 한 개 분량의 메모리 영역을 확보한다.
    - 초기 상태의 제어 정보를 기록한다.
- 디스크립터를 반환한다.
- 네트워크 어플리케이션은 프로토콜 스택에게 디스크립터를 전달하여 송수신동작을 수행한다.

# STORY 02 서버에 접속한다

## 1. 접속의 의미

- 클라이언트 측의 소켓에 서버 제어 정보(IP, PORT 등) 을 기록한다.
- 서버 측의 소켓에 클라이언트 제어 정보를 기록한다.
    - 프로토콜 스택이 송신하여 서버측에서 받은 정보를 기록한다.
- 데이터 송수신 시 해당 데이터를 일시적으로 저장하기 위한 버퍼 메모리를 확보한다.
- 위의 모든 동작이 접속 동작에 해당한다.

## 2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

- 데이터 송수신 시 전달하고자 하는 실제 데이터 가장 앞에 제어 정보를 기록하여 정보를 주고받는다. (헤더)
    - 접속, 데이터 송수신, 연결 종료 등의 동작에 필요한 정보를 포함한다.
- 서버와 클라이언트 간의 통신 과정에서 데이터를 공유하기 위해 헤더에 기록한다.
    - 통신 과정에서 전달받은 정보를 각각의 소켓에 기록하여 진행상황을 파악한다.
    - 물리적으로 떨어져있는 기기간의 정보를 주고받기 위한 과정이다.
    - 두 기기간의 스펙이 다르더라도 주고 받는 메시지를 해석하여 통신할 수 있다.

## 3. 접속 동작의 실제

- 서버에게 접속 요청을 보낸다. (SYN)
    - 어플리케이션은 Socket 라이브러리의 connect 를 호출한다.
    - 프로토콜 스택에게 송신을 의뢰하면 TCP 계층으로 제어가 이동한다.
    - 클라이언트와 서버의 포트 정보를 이용하여 TCP 헤더를 추가한다.
        - 컨트롤 비트인 SYN 을 1 로 변환한다.
    - IP 계층에서 서버와 통신 동작을 수행한다.
- 서버로부터 응답을 받으면 서버에게 정상적으로 수신했다는 요청을 보낸다. (ACK + SYN)
    - TCP 헤더를 만들어 컨트롤 비트인 ACK 를 1 로 변환한다.
    - IP 계층에서 서버와 통신 동작을 수행한다.
- 클라이언트가 서버도 정상적으로 수신했다는 응답을 확인했다는 요청을 보낸다. (ACK)
    - TCP 헤더의 SYN 이 1 이면 서버도 정상적으로 처리되었다는 의미이다.
    - 서버와 클라이언트 모두 정상적으로 동작하는 것이 확인되었으니 소켓에 제어 정보를 저장한다.
    - 서버와의 접속이 정상적으로 이루어졌다는 것을 알리기 위해 서버에게 ACK 가 1 인 TCP 헤더를 반송한다.
- 위의 과정을 거치면 클라이언트와 서버가 연결이 된 상태이다.

# STORY 03 데이터를 송수신한다

- 브라우저에서 받은 실제 데이터를 서버에 송수신하는 동작을 설명한다.

## 1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

- Socket 라이브러리의 write 를 실행하기 전의 동작이다.
- 어플리케이션에서 받은 실데이터를 받은 프로토콜 스택은 송신용 버퍼에 저장 후 송수신한다.
    - 어플리케이션에 따라서 보내고자 하는 데이터를 한번에 보내기도, 매우 작은 단위로 보내기도 한다.
    - 버퍼를 거치지 않고 바로 통신할 경우 효율이 안좋을 수 있다.
    - 따라서 버퍼에 저장 후 적절한 패킷을 생성하여 송수신한다.
        1. 적절한 데이터의 크기를 판단하여 해당 크기를 채울 데이터가 모이면 데이터를 송신한다. (MSS)
        2. MSS 만큼의 데이터가 모이지 않더라도 일정 시간이 지나면 데이터를 송신한다.
    - 네트워크의 효율과 송신 시간을 고려하여 진행된다. 이는 OS 에 따라 다르다.
    - 어플리케이션 성격에 따라서 버퍼를 거치지 않고 바로 송신하도록 하는 설정도 부여할 수 있다. (대화형)

## 2. 데이터가 클 때는 분할하여 보낸다

- 송신하고자 하는 데이터가 클 경우에는 송신 버퍼가 MSS 의 길이가 초과하여, MSS 크기에 맞게 데이터를 분할하여 송신한다.
    - 어플리케이션 데이터 = HTTP 헤더 + 메시지 본문
- 어플리케이션 데이터를 분할하여 작은 패킷단위로 나누고, 관련 TCP, IP, MAC 등의 헤더를 추가한다.

## 3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다

- TCP 통신은 데이터 송수신 시 정상적으로 처리되지 않으면 재송신하는 기능이 있기 때문에 통신이 정상적으로 이루어졌는지 확인하는 과정이 필요하다.
- 어플리케이션 데이터를 분할하여 시작점의 위치를 기록한 시퀀스 번호를 전달한다.
    - 시퀀스 초기 번호는 임의의 난수로 설정되어 있다.
        - 악의적인 공격을 대비하기 위해 임의의 난수로 설정한다.
        - 접속 과정에서 해당 값을 주고받는다.
    - 초기 번호를 기준으로 MSS 의 크기를 기준으로 다음 패킷의 시퀀스 번호가 결정된다.
- 수신측에서 시퀀스 번호를 이용하여 보내고자 하는 데이터가 모두 정상적으로 수신되었는지 조립하여 판단한다.
- 수신측에서는 수신한 데이터를 조립하여 ACK 를 마지막 바이트 + 1 의 값으로 변경하여 응답한다.
    - ACK 의 값을 확인하여 서버가 어디까지 수신했는지 알 수 있다.

## 4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

- 네트워크 문제로 통신이 지연될 경우 재송신하는 과정이 진행된다.
- 지연 시간의 기준은 적절한 값으로 설정하기 위해 대기 시간을 동적으로 관리한다.
- ACK 번호가 돌아오는 시간을 측정해두어 그때마다 적절한 대기 시간을 재설정한다.

## 5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다

- 클라이언트 측에서 데이터를 송신하고 서버 측에서 이를 확인하여 ACK(수신 확인 응답) 을 하면 효율성이 떨어질 수 있다.
- 따라서, 여러번 송신 과정을 거친 후 ACK 를 보내는 방식을 취한다.
- 수신 버퍼에 수신한 데이터를 저장하여 수신 데이터를 조립하는데, 한번에 여러번 송신을 보내면 수신 버퍼가 가득차 오류가 발생한 것처럼 처리될 수 있다.
- 수신 측에서 수용할 수 있는 수신 버퍼의 잔여 크기를 클라이언트에게 공지하여 이를 보완할 수 있다. (윈도우 제어 방식)

## 6. ACK 번호와 윈도우를 합승한다

- 윈도우 사이즈를 알리는 과정은 수신 버퍼에서 데이터를 추출하여 어플리케이션에게 건네주었을 때 필요하다.
    - 송신측에서 버퍼 변화를 알 수 없는 경우에 필요하다.
- ACK 번호를 알리는 과정은 데이터를 수신했을 때 모든 과정에서 필요하다.
- 이는 모든 요청에 대해 계속해서 응답을 보내야 하므로 효율성이 떨어져, 2개 이상의 응답을 한 번에 합승하여 응답한다.
    - ACK 번호 + 윈도우 사이즈 응답
    - 여러 요청이 한번에 들어와 ACK 번호 응답이 여러 개 쌓일 경우 가장 최신 정보만 응답
    - 수신 버퍼의 변화가 여러번 이루어지는 경우 가장 최신 정보만 응답

## 7. HTTP 응답 메시지를 수신한다

- 클라이언트는 HTTP 응답 메시지를 수신하면 통신 과정이 끝난다.
- 서버에게 응답 메시지를 받기 위해 read 를 호출한다.
- 서버와 마찬가지로 클라이언트도 수신 버퍼에 저장 후 어플리케이션에게 전달된다.

# STORY 04 서버에서 연결을 끊어 소켓을 말소한다

## 1. 데이터 보내기를 완료했을 때 연결을 끊는다

- 더이상 송수신할 데이터가 없을 경우 연결을 끊는다.
  - 일반적으로 웹서버와의 통신의 경우 웹서버에서 더이상 송신할 데이터가 없을 경우 연결을 끊는다.
  - 경우에 따라 처음 데이터를 송신하는 어플리케이션(클라이언트) 측에서 연결을 종료하는 경우도 있다.
  - 클라이언트와 서버 둘 중 한곳에서 연결을 끊으면 통신 연결이 종료된다.
- 웹 서버 기준으로 더이상 송신할 데이터가 없으면 서버는 Socket 라이브러리의 close() 를 호출한다.
  - 서버측의 프로토콜 스택은 TCP 헤더를 만들고 **TCP 헤더에 FIN 컨트롤비트를 1로 설정**한다.
  - IP 담당 부분에 클라이언트에게 송신하도록 의뢰한다.
- 클라이언트는 종료 메시지를 수신하고 서버에게 응답한다.
  - FIN 에 1을 설정한 TCP 헤더가 도착하면 해당 내용을 소켓에 기록한다.
  - 제대로 응답을 받았다고 알리기 위해 서버에게 ACK 번호를 응답한다.
- 어플리케이션은 서버에서 받은 데이터를 읽기 위해 read() 를 호출한다.
  - 종료 메시지를 받았을 경우 수신 버퍼에 남아있는 데이터만 넘긴다.
  - 프로토콜 스택은 서버에서 종료 메시지를 보냈다는 내용을 어플리케이션에게 알린다.
- **클라이언트 측의 어플리케이션도 종료하기 위해 Socket 의 close() 를 호출한다.**
  - 서버 동작과 동일하게 TCP 헤더에 FIN 을 1로 설정 후 서버에게 송신한다.
  - 서버에서 ACK 번호가 돌아오면 서버와의 통신이 종료된다.

## 2. 소켓을 말소한다

- 통신 연결을 종료하더라도 클라이언트와 서버 측에서는 각각의 소켓이 남아있다.
- **소켓은 오동작을 막기 위해 바로 제거하는 것이 아닌 일정 시간이 지난 후 말소한다.**
  - 클라이언트 FIN 송신 → 서버 ACK 송신 → 서버 FIN 송신 → (네트워크 문제 발생) → 클라이언트 ACK 송신
  - 서버가 FIN 송신 후 네트워크 문제가 발생하여 ACK 를 수신하지 못할 경우 서버는 FIN 을 재송신한다.
  - 이때 클라이언트의 소켓이 말소되어 있으면 어느 소켓에게 온 요청인지 알 수 없다.
  - 심지어는 말소 후 동일한 포트번호를 가지는 소켓이 새로 생성되었다면, 새로 생성된 소켓에게 종료 요청이 올 수도 있다.
- 소켓은 재송신 동작을 포함하여 모든 동작이 완전히 끝나는 시간을 기준으로 대략 분단위의 시간을 기다린 후 말소한다.

## 3. 데이터 송수신 동작을 처리한다

- 데이터 송수신 동작의 모든 과정을 정리한다.
- 소켓을 작성한다.
  - 서버측에서 어플리케이션이 동작할 때 소켓을 만들고 접속 대기 상태로 설정한다.
  - 클라이언트 측에서 서버와의 연결을 위해 소켓을 생성한다.
- 서버에 접속한다.
  - 클라이언트가 SYN 이 1인 TCP 헤더를 만들어 서버에게 보낸다.
    - TCP 헤더에는 시퀀스 번호의 초기값도 포함되어 있다.
    - 서버에서 클라이언트에 데이터를 송신할 때 이용하는 윈도우 값도 포함되어 있다.
  - 서버도 SYN 이 1인 TCP 헤더를 만들어 클라이언트에게 보낸다.
    - TCP 헤더에는 클라이언트와 마찬가지로 시퀀스 번호 초기값과 윈도우가 포함되어 있다.
    - ACK 번호도 포함되어 있다.
  - 클라이언트도 ACK 번호가 포함된 요청을 서버에게 보낸다.
- 데이터를 송수신한다.
  - 웹 서버의 경우 클라이언트는 서버에 리퀘스트 메시지를 보낸다.
    - 데이터를 적절한 크기로 분할하여 TCP 헤더를 붙인 후 보낸다.
    - TCP 헤더에는 분할된 데이터가 몇번째 바이트부터 시작되는지 나타내는 시퀀스 번호가 포함되어 있다.
  - 서버는 ACK 번호가 포함된 요청을 클라이언트에게 반송한다.
    - 수신 버퍼의 변화가 있을 경우 수용 가능한 윈도우 크기도 포함되어 있다.
  - 서버는 클라이언트에게 데이터를 송신한다.
    - 클라이언트의 요청과 마찬가지로 패킷단위로 분리하며 시퀀스 번호를 포함하여 송신한다.
  - 클라이언트는 ACK 번호를 반송한다.
    - 통신은 양방향이므로 클라이언트 측에서도 수용 가능한 윈도우 크기를 포함하여 전송한다.
- 소켓 통신 연결을 종료한다.
  - 웹 서버의 경우 서버에서 FIN 이 1인 TCP 헤더를 보낸다.
  - 클라이언트는 ACK 번호를 보내 정상응답을 회답한다.
  - 클라이언트 측에서도 연결을 종료하기 위해 FIN 이 1인 TCP 헤더를 보낸다.
  - 서버도 ACK 번호를 보내 연결을 종료한다.

# STORY 05 IP 와 이더넷의 패킷 송수신 동작

## 1. 패킷의 기본

- 패킷은 헤더와 데이터 두 부분으로 구성되어 있다.
  - 헤더에는 패킷의 제어 정보가, 데이터는 실제 데이터가 포함되어 있다.
  - IP 의 패킷 : IP 헤더 + (TCP 헤더 + 데이터 조각)
  - 이더넷의 패킷 : MAC 헤더 + (IP 헤더 + (TCP 헤더 + 데이터 조각))
- **송신처의 IP 계층이 보낸 메시지는 가장 가까운 중계 장치에게 전달되며, 중계 장치가 관리하는 테이블 정보와 대조하여 다음 중계 장치 위치를 찾아 수신처를 찾는다.**
  - 클라이언트 → 허브 → 라우터 → … → 라우터 → 허브 → 서버

## 2. 패킷 송수신 동작의 개요

- IP 담당 부분은 패킷을 상대에게 송출하는 역할을 한다. (통신의 시작점)
  - 허브나 라우터같이 패킷을 ‘운반’ 하는 역할은 없다.
- 데이터를 송신한다.
  - TCP 담당 부분이 IP 담당 부분에게 패킷 송신을 의뢰한다.
    - 데이터에 TCP 헤더를 붙이며, 도착지 정보(IP) 등을 건네준다.
  - IP 담당 부분은 네트워크용 하드웨어(LAN 어댑터 등) 에게 전달한다.
    - IP 담당 부분은 TCP 에게 받은 데이터에 IP 헤더와 MAC 헤더를 추가한다.
      - IP 헤더 : IP 프로토콜에 규정된 규칙에 따라 IP 주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어 정보를 기록한 것
      - MAC 헤더 : 이더넷 등의 LAN 을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보를 기록한 것
    - 패킷을 0또는 1의 비트 형태로 변환하여 하드웨어에게 전달한다.
    - **네트워크용 하드웨어는 디지털 데이터를 전기나 빛 신호로 바꾸어 케이블에 송출한다.**
- 데이터를 수신한다.
  - 케이블의 신호를 받은 하드웨어는 데이터로 변환하여 IP 담당 부분에게 전달한다.
  - IP 담당 부분은 TCP 헤더와 데이터 조각을 TCP 담당 부분에게 전달한다.
- TCP 담당 부분은 신뢰있는 데이터 통신을 위해 헤더의 정보를 해석하여 소켓에 기록하는 과정이 포함되어 있지만, IP 담당 역할은 출발지에서 도착지로의 전달 뿐이다.
  - 데이터 수신 순서나 패킷 유실 등의 문제는 IP 가 아닌 TCP 의 담당 역할이다.
  - IP 는 목적지에 잘 도착하기만 하면 역할이 끝난다.

## 3. 수신처 IP 주소를 기록한 IP 헤더를 만든다

- TCP 담당 부분에게 데이터 송수신 요청을 받으면 IP 헤더를 만든다.
  - 송신처 IP 주소 : 적절한 LAN 어댑터 정보 사용 (LAN 어댑터에 매칭된 IP)
  - 수신처 IP 주소 : 어플리케이션에게 받은 정보 그대로 사용
- 수신처의 IP 는 라우터의 경로표(라우팅 테이블) 의 정보를 이용하여 패킷을 전달한다.
  - Network Destination : 목적지 IP 주소
  - Gateway : 다음 라우터의 IP 주소
  - Interface : LAN 어댑터의 IP 주소

## 4. 이더넷용 MAC 헤더를 만든다

- 이더넷은 TCP/IP 와 다른 구조로 관리하기 때문에 이를 위한 MAC 헤더를 추가한다.
  - 송신처 MAC 주소 : 선택된 LAN 어댑터의 MAC 주소
  - 수신처 MAC 주소 : 현재 패킷을 수신할 기기의 MAC 주소(ex. 라우터의 MAC 주소)
  - 이더 타입 : MAC 헤더 뒤의 내용이 어떤 프로토콜인지 나타낸다.
    - 0800 : IP 프로토콜
    - 0806 : ARP 프로토콜

## 5. ARP 로 수신처 라우터의 MAC 주소를 조사한다

- 동일 네트워크 상의 모든 기기에게 요청을 보내(브로드캐스트) 특정 IP 주소에 해당하는 기기의 MAC 주소를 받는다.
  - 매번 요청을 보내면 비효율적이기 때문에 메모리 영역에 ARP 캐시를 관리한다.

## 6. 이더넷의 기본

- 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술
  - 이더넷의 변천사 : 원형 → 허브 → 스위치
  - 허브 : 연결되어 있는 모든 기기에 메시지 전송 후 수신처가 아닌 기기는 메시지 폐기
  - 스위치 : 수신처 기기에만 메시지 전달

## 7. IP 패킷을 전기나 빛의 신호로 변환하여 송수신한다

- LAN 어댑터는 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크 케이블에 송출한다.
  - LAN 드라이버의 도움이 필요하다.
- LAN 어댑터는 사용 전 반드시 초기화 과정을 거쳐야 한다.
  - ROM 에 설정되어 있는 MAC 주소를 읽어와 MAC 회로에 설정한다.
  - 하드웨어 이상 검사, 초기 설정 등의 작업도 수행한다.

## 8. 패킷에 3개의 제어용 데이터를 추가한다

- LAN 드라이버는 IP 담당 부분에서 패킷을 받으면 LAN 어댑터의 버퍼 메모리에 복사한다.
- 복사를 마친 후 패킷을 송신하도록 MAC 회로에 명령을 보내면 MAC 회로의 작업이 시작된다.
- MAC 회로는 패킷에 3개의 제어용 데이터를 추가한다.
  - 프리앰블(56비트)
    - 패킷의 가장 앞 부분에 추가한다.
    - 송신하는 패킷을 읽을 때의 타이밍을 위해 조절하는 역할을 한다.
    - 1010101010.. 등 1 과 0 이 순서대로 반복되는 형태를 띈다.
  - 스타트 프레임 딜리미터(8비트)
    - 패킷의 가장 앞 부분에 추가한다.
    - 패킷의 시작 점을 나타내는 역할을 한다.
    - 1010..11 등 1 과 0 이 순서대로 반복되다가 마지막에 11 인 형태를 띈다.
  - FCS(32비트)
    - 패킷의 가장 뒷 부분에 추가한다.
    - 패킷을 운반하는 도중에 잡음 등의 영향으로 파형이 흐트러져 데이터가 변한 경우 검출하는 역할을 한다.
- 전기 또는 빛 신호로 변환하여 케이블에 송출할 때에는 데이터 신호와 클록 신호를 합친 신호를 보낸다.
  - 디지털 신호가 1 또는 0 이 이어지는 형태일 경우 신호의 변화가 없어 판단하기 어렵다.
  - 클록 신호를 알면 수신한 신호와 클록 신호를 대조하여 데이터 신호를 추출할 수 있다.
  - **클록 신호의 타이밍을 잡기 위한 신호가 프리앰블이다.**

## 9. 허브를 향해 패킷을 송신한다

- 허브는 반이중 모드 방식으로 동작한다.
  - 케이블에 송출되는 신호가 있는지 확인 후 없으면 송출한다.
  - 여러 대의 기기에서 동시에 송출하여 여러 신호가 동시에 송출되는 경우 충돌이 발생한다.
  - 충돌이 발생하면 재밍 신호를 보내 알리고, 잠시 대기 후 재송신한다.
  - 여러번 재송신 시 충돌이 발생할 경우 오류로 판단한다.

## 10. 돌아온 패킷을 받는다

- 패킷이 올바르게 수신되었는지 확인한다.
  - 받은 패킷의 프리앰블로 파형의 타이밍을 계산하고, 스타트 프레임 딜리미터가 나오면 디지털 데이터 신호로 변환한다.
  - MAC 회로에서 신호를 맨 앞부터 차례대로 디지털 데이터로 변환하여 버퍼 메모리에 저장한다.
  - FCS 의 값을 검사하여 수신한 값을 검증한다.
    - 오류 패킷일 경우 폐기한다.
- MAC 헤더를 확인한다.
  - 허브의 경우 모든 기기에게 메시지를 전송하므로, 수신처 MAC 주소와 동일한지 검증한다.
  - 수신처 정보와 다를 경우 폐기한다.
  - 수신처 정보와 동일할 경우 버퍼 메모리에 저장한다.
  - MAC 회로의 과정을 마치면 컴퓨터 본체에게 인터럽트를 통해 수신 과정을 알린다.

## 11. 서버의 응답 패킷을 IP 에서 TCP 로 넘긴다

- LAN 드라이버는 MAC 헤더의 이더 타입이 0800 일 경우 TCP/IP 프로토콜 스택에 넘긴다.
- IP 담당 부분은 IP 헤더를 조사하여 포멧을 확인한다.
- LAN 어댑터에 할당된 IP 주소와 수신처 IP 주소가 일치하는지 확인한다.
  - 수신처 정보와 다를 경우 ICMP 메시지를 통신 상대에게 전달한다.
    - 클라이언트 PC 의 경우 패킷을 중계하지 않으므로 본인 이외의 패킷이 오는 경우는 없다.
    - Destination unreachable 메시지를 담은 ICMP 를 보낸다.
  - 수신처 정보와 동일할 경우 수신한 데이터를 취합하여 TCP 담당 부분에게 전달한다.
    - 통신 회선이나 LAN 은 짧은 패킷만 다루므로 하나의 데이터에 여러 패킷으로 분리되어 있다.
    - IP 헤더의 플래그 값을 확인하여 분할된 패킷인지의 여부를 알 수 있다.
      - 분할 패킷일 경우 IP 담당 부분 내부의 메모리에 일시적으로 보관한다.
      - 모든 패킷이 취합된 후 TCP 에게 전달한다.
    - 분할 패킷의 식별자인 ID 와 분할 위치를 나타내는 프래그먼트 오프셋을 이용하여 취합한다.
- TCP 담당 부분은 IP 헤더의 송수신처 정보를 이용하여 해당하는 소켓을 찾는다.

# STORY 06 UDP 프로토콜을 이용한 송수신 동작

## 1. 수정 송신이 필요없는 데이터 송신은 UDP 가 효율적이다

- TCP 는 데이터를 확실히 전달하며 효율적으로 관리해야 하기 때문에 과정이 복잡하다.
  - 데이터를 확실히 전달하기 위해서 데이터를 어디까지 받았는지를 응답해야 한다.
  - 데이터를 효율적으로 관리하기 위해서 여러 개의 패킷으로 분리한다.

## 2. 제어용 짧은 데이터

- **제어용으로 실행하는 정보 교환은 한 개의 패킷으로 끝나는 경우가 많으므로 UDP 를 사용한다.**
  - ex) DNS 서버에 IP 조회
  - 에러가 발생할 경우 단순하게 재송신하면 되므로 패킷 또는 윈도우 등을 고려할 필요가 없어 간단하다.

## 3. 음성 및 동영상 데이터

- **음성이나 동영상 같이 응답 속도가 중요한 데이터의 경우에도 UDP 를 사용한다.**
  - TCP 를 사용하여 재송신 할 경우 속도가 늦어질 수 있으며, 재생 시간이 넘어간 후 수신한다면 데이터 재송신의 의미가 없다.
