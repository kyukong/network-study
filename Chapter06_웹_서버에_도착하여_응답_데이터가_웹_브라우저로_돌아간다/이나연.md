# Chapter_06 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다_불과 몇 초인 ‘긴 여행’의 끝

## STORY 01 | 서버의 개요

### 1. 클라이언트와 서버의 차이점

- 클라이언트와 서버는 네트워크에 관한 부분, 즉 LAN 어댑터, 프로토콜 스택, Socket 라이브러리 등의 기능이 같지만, 사용하는 방법은 다름
- 서버의 애플리케이션은 동시에 다수의 클라이언트 PC와 대화함
- 서버 애플리케이션은 클라이언트 애플리케이션과 구조가 다름

### 2. 서버 애플리케이션의 구조

클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 서버 애플리케이션이 클라이언트와 1대 1로 대화하는 방법이 일반적임

1) 서버 프로그램을 접속을 기다리는 부분과 클라이언트와 대화하는 부분의 둘로 나누어 만듦

2) 서버 프로그램을 작동해서 설정 파일 읽기 등의 초기화 동작을 마쳤을 때 접속을 기다리는 부분 실행 (소켓을 작성하고 소켓을 클라이언트에서의 접속 동작을 기다리는 상태로 만든 채 쉬는 상태가 됨)

3) 클라이언트가 접속했을 때 다시 작동하여 접속을 기다림

4) 클라이언트와 대화하는 부분을 작동시켜서 그곳에 접속이 끝난 소켓을 건네주고 동작을 계속하면 클라이언트와 대화하는 부분은 접속이 끝난 소켓을 사용하여 클라이언트와 대화하기 시작함

5) 대화가 끝나면 연결을 끊고 이 부분을 종료함

→ 클라이언트가 접속했을 때, 새로 프로그램을 기동하는 부분에서 다소 시간이 걸리고, 응답 시간이 추가로 소요됨

### 3. 서버측의 소켓과 포트 번호

서버쪽 송/수신 동작

1) 소켓을 만듦

2-1) 소켓을 접속 대기 상태로 만듦
2-2) 데이터를 송/수신

3) 데이터를 송/수신

4) 파이프를 분리하고 소켓을 말소

- 접속 패킷이 도착하면 응답 패킷을 반송하여 접속 접수 동작을 실행함
- 접속 대기의 소켓을 복사하여 새로운 소켓을 만들고, 접속 상대의 제어 정보를 새 소켓에 저장함
- 이때 접속 대기 소켓을 복사하여 만든 새 소켓은 원래의 포트를 따라야 함.

여기서 소켓을 구별하기 위해서는 네 가지 정보를 사용

1. 클라이언트의 ip 주소
2. 클라이언트의 포트 번호
3. 서버측의 ip 주소
4. 서버측의 포트 번호

소켓을 식별하기 위해 디스크립터를 사용하는 이유

접속 대기의 소켓에는 클라이언트의 ip 주소와 포트 번호가 기록되지 않음.
디스크립터라는 한 개의 정보로 식별하는 쪽이 간단

## STORY 02 | 서버의 수신 동작

### 1. LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다

- LAN 어댑터의 MAC 부분이 패킷을 신호로부터 디지털 데이터로 되돌리고 FCS를 점검한 후 버퍼 메모리에 저장함
- LAN 드라이버가 MAC 헤더로부터 프로토콜을 판단하여 프로토콜 스택에 패킷을 건내줌

### 2. IP 담당 부분의 수신 동작

1) 프로토콜 스택의 IP 담당 부분은 IP 헤더를 점검

2) 자신을 대상으로 한 것인지 판단

3) 조각 나누기에 의한 패킷의 분할이 있는지 조사

4) TCP 담당 부분 또는 UDP 담당 부분에 패킷을 건네줌

### 3. TCP 담당 부분이 접속 패킷을 수신했을 때의 동작

패킷이 접속 동작의 패킷인 경우 TCP 담당 부분

1) TCP 헤더의 SYN의 컨트롤 비트를 확인

2) 수신처 포트 번호를 조사

3) 해당하는 접속 대기 소켓을 복사하여 새 소켓을 작성

4) 송신처의 IP 주소나 포트 번호 등을 기록

### 4. TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작

데이터의 패킷을 수신한 경우 TCP 담당 부분

1)도착한 패킷의 송신처 IP 주소, 송신처 포트 번호, 수신처 IP 주소, 수신처 포트 번호로부터 해당하는 소켓을 판단

2) 데이터의 조각을 연결해서 수신 버퍼에 보관

3) 클라이언트에게 ACK를 돌려줌

### 5. TCP 담당 부분의 연결 끊기 동작

서버측에서 애플리케이션이 Socket 라이브러리의 close를 호출하고, TCP 담당 부분이 FIN 컨트롤 비트에 1을 설정한 TCP 헤더를 만든 후 IP 담당 부분에 의뢰하여 클라이언트에 보냄

클라이언트는 ACK 번호를 반송 후 close를 계속 호출하고, FIN을 1로 한 TCP 헤더를 서버에 보낸 후 서버가 ACK 번호를 반송하면 연결 끊기 동작은 끝남